"""
DataGen.m
A code to generate database (inputs and targets) using circles.
     input data:      The volume fraction of interface cell and its adjacent cells
     target:          The curvature o interface cell which is constant for a circle
     saved .mat file: contains an input matrix with nine columns and a target matrix with one column
More data could be generated by changing the radius of the circle or the grid spacing.
"""

import tensorflow as tf
import numpy as np
from scipy import io

# constant variable
num_points = 256000                    # np:
num_x = 2000                           # nx: fixed grid of 2000x2000
num_y = 2000
L = 1                                  # L: 1x1 domain
DTheta = 2 * np.pi / (num_points - 1)  # endpoint included twice
xo = 0.5                               # xo: circle center or domain center in coordinate x
yo = 0.5                               # yo: circle center or domain center in coordinate y
N_D = 188232                           # N_D: total number of relationships

# generate list
xs = tf.zeros([1, 4])
ys = tf.zeros([1, 4])

# generate the output matrix 可有可无
datafra = tf.zeros([1, N_D], dtype=tf.dtypes.float32, name='datafra')  # input data: volume fraction
datacur = tf.zeros([9, N_D], dtype=tf.dtypes.float32, name='datacur')  # target data: curvature

# generate the circles with different radii
r_0 = tf.range(0.00225, 0.05 + 0.001, 0.001)   # circles range from 0.00225 to 0.475 with increments of 0.001
r_1 = tf.range(0.075, 0.475 + 0.025, 0.025)    # circles range from 0.075 to 0.475 with increments of 0.025
r = tf.concat((r_0, r_1), axis=0, name='r')    # composite into one array 合并数组

for i in range(1, max(r.shape)):
    ro = r

    # Constructing the Interface Shape
    for j in range(1, num_points):
        theta = DTheta * (j - 1)
        xp = xo + ro * tf.math.cos(theta)
        yp = yo + ro * tf.math.sin(theta)

    # Construct fixed grid
    # num_y = num_x
    h = L / (num_x - 1)

    for m in range(1, num_x):
        x = h * (m - 1)

    for n in range(1, num_y):
        y = h * (n - 1)

    # Construct the marker
    xi = tf.zeros([num_x - 1, num_y - 1])  # Set the initial value of xi

    for k in range(1, num_points - 1):

        ip1 = tf.floor(xp * (num_x - 1)) + 1        # floor(x) 舍入到最近似整数
        jp1 = tf.floor(yp * (num_y - 1)) + 1

        ip2 = tf.floor(xp[k + 1] * (num_x - 1)) + 1
        jp2 = tf.floor(yp[k + 1] * (num_y - 1)) + 1

        xs[1] = xp[k]
        xs[2] = xp[k + 1]
        xs[3] = xp[k + 1]
        xs[4] = xp[k + 1]  # Add two in between points

        ys[1] = yp[k]
        ys[2] = yp[k + 1]
        ys[3] = yp[k + 1]
        ys[4] = yp[k + 1]

        if ip1 != ip2:
            if ip1 < ip2:
                xv = (ip2 - 1) * h

            elif ip1 > ip2:
                xv = (ip1 - 1) * h

            else:
                yv = yp[k] + ((yp[k + 1] - yp[k]) / (xp[k + 1] - xp[k])) * (xv - x[k])

        if jp1 != jp2:

            if jp1 < jp2:
                yh = (jp2 - 1) * h

            elif jp1 > jp2:
                yh = (jp1 - 1) * h

            else:
                xh = xp[k] + ((xp[k + 1] - xp[k]) / (yp[k + 1] - yp[k])) * (yh - yp[k])

        if ip1 != ip2 and jp1 == jp2:
            xs[2] = xv
            ys[2] = yv

        if jp1 != jp2 and ip1 == ip2:
            xs[2] = xh
            ys[2] = yh

        if ip1 < ip2 and jp1 != jp2:
            xs[2] = xv
            ys[2] = yv
            xs[3] = xh
            ys[3] = yh

            if xv > xh:
                xs[2] = xh
                ys[2] = yh
                xs[3] = xv
                ys[3] = yv

        if ip1 > ip2 and jp1 != jp2:

            xs[2] = xv
            ys[2] = yv
            xs[3] = xh
            ys[3] = yh

            if xv < xh:
                xs[2] = xh
                ys[2] = yh
                xs[3] = xv
                ys[3] = yv

        for v in range(1, 3):

            ip = tf.floor(0.5 * (x[v] + xs[v + 1]) * (num_x - 1)) + 1
            jp = tf.floor(0.5 * (ys[v] + ys[v + 1]) * (num_y - 1)) + 1
            dx = -(xs[v + 1] - xs[v])
            xi[ip, jp] = xi(ip, jp) + (0.5 * (y[v] + ys[v + 1]) - y[jp]) * dx / h / h

            for w in range(1, jp - 1):
                xi[ip, k] = xi(ip, k) + h * dx / h / h  # start at the bottom

    ip0 = -1
    jp0 = -1
    ncells = 0
    cellloc = tf.zeros([np, 2])
    cur = tf.zeros([np, 1])
    fra = tf.zeros([np, 9])

    for a in range(1, np - 1):

        ip = tf.floor(xp(a) * (num_x - 1)) + 1
        jp = tf.floor(yp(a) * (num_y - 1)) + 1

        if ip != ip0 or jp != jp0:
            ncells = ncells + 1
            ip0 = ip
            jp0 = jp
            cellloc[ncells, :] = [ip0, jp0]  # 修改

    if cellloc[ncells, :] == cellloc[1, :]:
        ncells = ncells - 1

    for b in range(1, ncells):
        cur = h / ro
        fra[b, 1] = xi(cellloc(b, 1) - 1, cellloc(b, 2) - 1)
        fra[b, 2] = xi(cellloc(b, 1) - 1, cellloc(b, 2))
        fra[b, 3] = xi(cellloc(b, 1) - 1, cellloc(b, 2) + 1)
        fra[b, 4] = xi(cellloc(b, 1), cellloc(b, 2) - 1)
        fra[b, 5] = xi(cellloc(b, 1), cellloc(b, 2))
        fra[b, 6] = xi(cellloc(b, 1), cellloc(b, 2) + 1)
        fra[b, 7] = xi(cellloc(b, 1) + 1, cellloc(b, 2) - 1)
        fra[b, 8] = xi(cellloc(b, 1) + 1, cellloc(b, 2))
        fra[b, 9] = xi(cellloc(b, 1) + 1, cellloc(b, 2) + 1)

    cur = cur[1: ncells, :]
    fra = fra[1: ncells, :]

    # Generate the database for different radii
    datacur = [datacur, cur]
    datafra = [datafra, fra]  # 修改

# negative curvature
datacur = [datacur, -1 * datacur]
datafra = [datafra, 1 - datafra]

io.savemat('Data/database.mat', {'datacur': datacur, 'datafra': datafra})
